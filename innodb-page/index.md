# Innodb Page


## InnoDB

- 起因：
  - MySQL中数据存储是在物理磁盘上，而真正的数据处理是在内存中执行。（考虑到磁盘读写速度非常慢，频繁的操作性能差）。

- 解决方案：
  - InooDB将一个表的数据划分为若干页（pages），以页作为磁盘与内存交互的基本单位，这些页通过 B-Tree索引联系起来，每页的默认大小为16kb（配置为 innodb_page_size）。
  - 这样保证每次至少读取1页数据到内存或写入磁盘，减少了内存与磁盘的交互次数，提升性能。

- 遵循缓存设计思想：
  - 时间维度：如果一条数据正在在被使用，那么在接下来一段时间内大概率还会再被使用。
    - 可以认为热点数据缓存都属于这种思路的实现。
  - 空间维度：如果一条数据正在在被使用，那么存储在它附近的数据大概率也会很快被使用。
    - InnoDB的数据页和操作系统的页缓存则是这种思路的体现。

- 其中，B-Tree索引就是聚簇索引（Clustered Index），这个索引的节点包含了所有列数据（也就是page）。二级索引的节点只有指向主键的指针。

## Page Structure

![mysql_page_structure](https://raw.githubusercontent.com/Hongmiao0207/repository/main/images/mysql_page_structure.png)

- File Header：存储页的通用信息。
- Page Heade：存储数据页专有的信息。
- Infimum + Supremum：页面中最小和最大记录。
- User Records：用户存储的记录内容。
- Free Space：页面中空闲空间。
- Page Directory：存储页中记录的相对位置。
- File Trailer：校验页是否完整。

### Infimum + Supremum

- 分别是最小记录和最大记录，属于MySQL为每个页添加的虚拟记录。
  - 目的：防止插入新记录时需要移动已经存在的记录的位置。
    - 最小记录永远位于页的最前面，最大记录永远位于页的最后面，这样可以避免记录移动，提高性能。
- 最小记录的记录头中 heap_no = 0，最大记录的记录头中 heap_no  = 1，正式记录中的 heap_no从2开始。
- 最小记录的 record_type = 2，最大记录的 record_type = 3。
- 最小记录是页中单链表的头节点，最大记录是页中单链表的尾节点。
- 它们的存在有助于确保B+树的有序性。

## 行格式的选择

- 不同行格式适用于不同的使用情景：
  - Compact：适用于常规的OLTP(联机事务处理)应用。
  - Dynamic & Compressed：适用与特定情况，比如包含大量变长字段或需要数据压缩的情况。

## Compact 行格式存储

InnoDB中的一种行格式，用于存储整个记录的数据。

- 对于每个记录，Compact行格式将数据存储在本页中。

- 对于较大的字段或行溢出数据，会使用溢出页来存储。

- 比如 Text类型。如果页存在于聚簇索引上，那么这个节点数据就会过大，会一下读出很多页，也会降低读取效率（假如我们本身没有想获取 Text 列的情况下）。
  - 因此，InnoDB对于变长字段，一般倾向于把它们存储到其他地方。如何存储，就和  **InnoDB行格式（Row Format）**有关。

- 行格式有四种：compact、redundant、dynamic & compressed。

可以通过创建或修改表的语句来指定 行格式：

```sql
CREATE TABLE table_name(
    ...    
)ROW_FORMAT=行格式;

ALTER TABLE table_name ROW_FORMAT=行格式;
```

### Compact行格式结构

![compact_row_format_structure](https://raw.githubusercontent.com/Hongmiao0207/repository/main/images/compact_row_format_structure.png)

### Compact行格式存储 - 变长字段长度列表

- 变长字段长度列表是compact行格式中的开头列表。
  
- 包含数据不为null，且类型为长度不定的，比如varchar、varbinary、text、json等。

- 不需要考虑它们到底占多少字节，省去列数据之间的边界定义。

- 存储格式：16进制。

- 排列顺序：16进制后的逆序排列。
  - 这种排列方式有助于在查找长度信息时提高效率。

### Compact行格式存储 - NULL值列表

- NULL值列表仅包含可以为NULL的字段，如果某个字段是 not null，这个字段就不会进入 NULL值列表中。

### Compact行格式存储 - 记录头信息

- 记录头固定为 5字节大小。

|名称|大小(bits)|描述|
|---|---|---|
|无用位/预留位|2|目前没用到|
|deleted_flag|1|标记记录是否被删除|
|min_rec_flag|1|b+树种非叶子节点最小记录标记|
|n_owned|4|当前记录拥有记录数|
|heap_no|13|该记录在堆中的位置信息（堆中的序号）|
|record_type|3|记录类型|
|next_record|16|页中下一条记录的相对位置|

其中：

- delete_flag：
  - 类型：0表示未删除；1表示删除。
  - 未删除的记录不会立即从磁盘移除，而是先打上删除标记，所有被删除的记录会组成一个垃圾链表。
  - 之后新插入的记录可能会重用到垃圾链表占用的空间，因此这个空间也称为**可重用空间**。

- heap_no：表示当前记录在本页的位置
  - 比如：heap_no=2，就表示这条记录在本页中的位置事2.
  - 实际上，InnoDB会自动地为每页加上两条虚拟记录，即最小记录0和最大记录1。两条记录被单独地放在 Infimum 和 Supremum的部分，但还是会占用页中位置0和1。

- record_type有4种类型：
  - 普通记录：0（10进制）或 000（2进制）。
  - B+树非叶子节点记录：1（10进制）或 001（2进制）。
  - 最小记录（伪记录的首记录）：2（10进制）或 010（2进制）。
  - 最大记录（伪记录的尾记录）：3（10进制）或 011（2进制）。

- next_record：
  - 表示从当前记录的真实数据到下一条记录的真实数据的地址**偏移量**。
  - 简单理解为单项链表，最小记录的下一个是第一条真实记录，最后一条真实记录的下一个是最大记录。
    - 从heap_no角度来看，即，0 -> 2 -> ... -> n -> 1，因为0是最小记录，1是最大记录，其中，n是最后一条真实记录。
      - 注：
        - 我们用箭头取代实际的偏移量，方便理解。
        - 但在页中记录之间的实际顺序是通过 DB_ROW_ID 这个隐藏列来决定的。

### Compact行格式存储 - 隐藏字段/列（属于记录的真实数据）

|列名|大小（字节）|描述|
|---|---|---|
|DB_ROW_ID|6|用作主键ID（非表中主键）|
|DB_TRX_ID|6|当前记录项的事务id|
|DB_ROLL_PTR|7|undo log指针|

- DB_ROW_ID：
  - 用作记录的物理标识符，不一定是主键。
  - 这个字段用户无法直接查看：
    - 因此你无法知道它里面存的数据究竟是什么格式。
    - 可能是 ID值，可能是物理化的ID值，或者其他，都不为认知，我们直知道它和ID相关。
  - 这个字段是可排序的（每个页中的记录依据它来排序）。
  - 每页中记录排序顺序是根据该字段/列决定的。
  - 它的生成规则：
    - 优先使用用户自定义主键作为主键。
    - 如果用户没定义主键，会选取一个unique键作为主键。
    - 如果表中没有定义unique键，则会为表默认添加一个生成 DB_ROW_ID的隐藏列最为主键。
  - 注：它不一定是全局唯一，只是在页内唯一。

- DB_TRX_ID
  - 用于记录当前记录项的事务ID，每个事务开始时，系统版本号（Transaction ID）会递增，因此它用于标识记录所属的事务。
  - 每开始一个新事务，系统版本号会自动递增，而事务开始时刻的系统版本号回作为事务id，事务commit的话，就会更新这里。

- DB_ROLL_PTR
  - 指向当前记录项的 undo log，用于撤销和回滚事务所作的更改。
  - 如果发生事务回滚，系统会从此字段来查找之前版本的数据，以将记录恢复到事务开始之前的状态。

### Compact行格式存储 - 行溢出数据（记录的真实数据）

varchar(m)最多能存储的数据：

- MySQL对一条记录占用的最大存储空间是有限制的，除BLONB或者TEXT类型的列外，其他所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不应该超过 65535个字节。
  - 不严谨的认为，MySQL一行记录占用的存储空间不能超过65535个字节。
  - 实际上，65535个字节包括：
    - 真实数据。
    - 真实数据占用的字节长度。
    - NULL值标识（如果是 not null就无此空间）。

- 而MySQL中磁盘与内存交互的基本单位是页，一般为16kb，16384个字节。而一行记录最大可以是65535个字节。
  - 造成了一页存不下一行数据的情况。

- 在 Compact 和 Redundant 行格式中，对于占用存储空间大的列，在记录真实数据处只会存储该列的一部分数据。把剩余的数据分散存储在几个其他页中，然后在记录的真实数据处用20个字节存储指向这些页的地址，从未可以找到剩余数据的所在页。

![recording_real_data_and_pointing_to_other_page_addresses](https://raw.githubusercontent.com/Hongmiao0207/repository/main/images/recording_real_data_and_pointing_to_other_page_addresses.png)

- 注：本记录只会存储该列的前768个字节的数据 和 一个指向其他页的地址。剩下的数据会存放的其他页。
  - 这种情况就叫做 行溢出，存储超过768字节数据的那些页面叫做**页内溢出页（Overflow Pages）**,这些页内溢出页中存储了行溢出数据的一部分。

- 注意：上述都是Compact 和 Redundant行格式中处理行溢出数据
  - InnoDB存储引擎中，默认的行格式是Dynamic。并且Dynamic与Compact很像，只是在处理行溢出数据上有差异。
    - 其中，Dynamic 不会在记录的真实数据处存放 前786个字节，而是将所有字节都存储在其他页面，这些页面称为**溢出页**。
  - 另外，Compressed 行格式 会采用 压缩算法对页面进行压缩，以节省空间。它通常不会涉及行溢出数据的问题，因为，它的设计目的时在页内压缩数据，而不是将数据存储在其他页中。

查询InnoDB默认行格式：

```sql
show variables like 'innodb_default_row_format';
```

## Page Directory (页目录)

（这段和ChatGPT描述的有出入）

- 它是InnoDB存储引擎内部的一个机制，用于帮助管理和加速数据页的查找，而不是直接管理记录。

- ChatGPT解释：Page Directory时用来定位数据页的工具，其原理不是通过分组实现。（我看网上教程写的是分组）？？？？？？？？

- 功能：保证数据量较大时的查找数据的速度。
  - 解决的问题：在页中，记录是按照主键大小正序串联成一个单链表。如果在数据量较大的时候根据主键进行遍历查询，效率太差。

- 大致原理：
  - 将所有正常的记录（包括最大、最小记录，不包括标记为已删除的记录）划分为几个组。（具体怎么划分还不确定）
  - 每个组的最后一条记录（也就是最大的记录）的头信息中的 n_owned属性表示该组内共有几条数据。
  - 将每组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页尾部的地方，这个位置就是 Page Directory。

- 规定：
  - 对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在 1-8条之间，剩下的分组中记录的条数范围只能在4-8条之间。

如图中，记录共有18条，InnoDB会把它们分成5组，第一组中只有一个最小记录：

![page directory](https://raw.githubusercontent.com/Hongmiao0207/repository/main/images/page_directory.png)

- 如何通过page directory查找指定主键值的记录：
  - 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的记录。
  - 通过记录的next_record属性遍历该槽所在组中的各个记录。

## Page Header

- 专门用来存储数据页相关的各种状态信息。

- PAGE_N_DIR_SLOTS：表示 Page Directory 中的槽数量。
- PAGE_HEAP_TOP：Free Space 的起始地址。Free Space 是数据页中尚未被记录使用的空间。
- PAGE_N_HEAP：当前数据页中的记录数量，但不包括已经标记为删除的记录。
- PAGE_FREE & PAGE_GARBAGE 共同表示了已删除记录的管理，已删除的记录通过链表结构组织起来，可以重新被利用。
  - PAGE_FREE：第一个已标记为删除的记录的地址（各个已删除的地址通过 next_record也会组成一个单链表）。
  - PAGE_GARBAGE：已删除记录占用的字节数。
- PAGE_LAST_INSERT：最后插入记录的位置。
- PAGE_DIRECTION：最后一条记录插入方向。
- PAGE_N_DIRECTION：一个方向连续插入的记录数（如果最后一条记录的插入方向改变，这个状态值会被清零重新统计）。
- PAGE_N_RECS：数据页中的记录数量，不包括最小和最大记录以及标记为删除的记录。
- PAGE_MAX_TRX_ID：用于标识对当前数据页进行修改的最大事务ID。
- PAGE_LEVEL：用于标识数据页在 B+ 树索引中的层级位置。
- PAGE_INDEX_ID：标识了数据页所属的索引ID。
- PAGE_BTR_SEG_LEAF & PAGE_BTR_SEG_TOP：用于标识 
 B+ 树叶子段和非叶子段的头部信息。仅在B+树的Root页定义。

## File Header

用来描述各种页都适用的通用信息：

- FIL_PAGE_SPACE_OR_CHKSUM 页的校验和（checksum值）。
  - 校验和是通过对页的内容进行计算得到的值，用于验证页面内容的完整性。有助于检测数据文件在存储或传输过程中是否发生了损坏。
- FIL_PAGE_OFFSET：为每一个页都有一个唯一的页号
  - 这个页号标识了数据文件中的页的位置，允许 InnoDB 存储引擎精确定位到特定页。
- FIL_PAGE_PREV 上一个页的页号。
- FIL_PAGE_NEXT 下一个页的页号。
  - 这两个属性用于构建双向链表，将数据文件中的页连接在一起。这对于页的管理和遍历非常有用。
- FIL_PAGE_LSN 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）。
- FIL_PAGE_TYPE：当前页的类型。
  - InnoDB 将不同类型的页用于不同的目的，例如数据页、索引页等。这个属性标识了当前页的用途。
- FIL_PAGE_FILE_FLUSH_LSN 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值。
- FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID 页属于哪个表空间。

## File Trailer

- MySQL中内存和磁盘的基本交互单位是页。如果内存中页被修改了，那么某个时刻一定会将内存页同步到磁盘中。如果在同步的过程中，系统出现问题，就可能导致磁盘中的页数据没能完全同步，也就是发生了脏页的情况。为了避免发生这种问题，mysql在每个页的尾部加上了File Trailer来校验页的完整性。

- File Trailer由8个字节组成：
  - 前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。
    - File Header和File Trailer都有校验和，如果两者一致则表示数据页是完整的。否则，则表示数据页是脏页。
  - 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）。

- 校验和（Checksum）：前4个字节表示页的校验和。校验和是通过对页的内容应用某种算法而得到的值，它用于验证页面内容的完整性。File Header 和 File Trailer 中的校验和应该是一致的。如果它们不一致，这可能表示页面在同步到磁盘时发生了错误或中断，即发生了脏页的情况。校验和的匹配是确保页面完整性的关键。

- 日志序列位置（LSN）：后4个字节表示页面被最后修改时对应的日志序列位置（LSN）。这个值记录了页面最后一次修改的日志位置，用于恢复和崩溃恢复。通过比较 File Header 和 File Trailer 中的 LSN，可以确定页面是否已经完全同步到磁盘。如果 LSN 不一致，表示页面的修改可能没有完全刷入磁盘。

