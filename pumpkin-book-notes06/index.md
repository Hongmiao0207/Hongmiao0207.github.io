# Machine Learning Notes 06


## 1 模型评估与选择

* 过拟合：就是不具备普遍性，在训练集中表现好，测试集和实际使用中一般
* 欠拟合：模型对于训练集的表现都不好

* 评估方法：将数据集分为训练集和测试集的方法
  * 留出法：简单因此常用
  * 交叉验证：应用于同算法异参数或异算法之间的比较
  * 自助法：应用于集成学习

## 2 线性模型

* 基本形式：$f(x) = w^T x + b$，其中，w是1*d维的向量，w和b确定后，模型就确定了。

### 2.1 线性回归

* 目的：使f(x)接近y值
* 如何达到目的，在x和y是已知的情况下，确定w和b的值即可
  * 如何确定w和b？
    * 最小二乘法：
      * $(w,b) = arg \ \ min_(w,b) \ \ \sum(f(x)-y)^2$
      * 即 $(w,b) = arg \ \ min_(w,b) \ \ \sum(y - wx - b)^2$
    * 最小二乘法几何意义：试图找到一个直线，使得样本到直线上的欧氏距离之和最小
    * 求最小值问题：就是分别对w、b求解其导数=0的过程
    * 在多元线性回归中，同理，只不过x从向量变成了矩阵
      * 令 $w^* = (w;b) = (w_1; w_2; ...; w_d; b)$，从一元线性回归方程中可得：
        * $w^*=arg \ \ min_{w^*} \ \ (y-Xw^*)^T (y-Xw^*)$，其中 X表示m*d维的x
          * 为什么一元线性回归的平方形式在多元中可以写成其乘以其转置的形式？
          * 这样成立的前提是X为满秩矩阵或者正定矩阵（full-rank or positive definite matrix）
        * 对$w^*$求导并让其导数式=0即可求得最优解，因此
          * $w^* = (X^TX)^{-1} X^T y$，其中，$(X^TX)^{-1}$为$(X^TX)$的逆矩阵
          * 逆矩阵：
            * 只有方阵才有逆矩阵
            * 矩阵和其逆矩阵相乘等于单位矩阵（从左上到右下的对角线上的元素为1，其余元素为0），效果等于实数中一个数乘以其倒数就等于1

### 2.2 正则化 Regularization

理想情况，$X^TX$是满秩的，但是实际情况中多数不是满秩，此时可解出多个w，且都能使均方误差最小化，如果选择一个w作为输出？---正则化项

* 什么是正则化？
  * 让w的个数最小化就是正则化
  * 形式：$\frac{\lambda}{2} ||W||^2_2, \lambda >= 0$，其中$||W||^2_2$ 表示二范数
  * 整体结构：$min\{\sum(y-W^Tx) + \frac{\lambda}{2}||W||^2_2\}, \lambda>=0$

### 2.3 对数线性回归 log-linear regression

* 对数线性回归解决的了，线性模型输出值之间可能存在跨度太大的问题，即将输出标记控制在指数尺度上。

通过 $ln y = w^Tx +b$，试图让 $e^{w^Tx+b}$ 逼近y。

<!-- ![单位阶跃函数](/posts/pumpkin-book-notes/unitStep.png) -->
{{< image src="/posts/pumpkin-book-notes/unitStep.png" caption="单位阶跃函数" height="303px" width="518px">}}

* 对数线性回归适合与回归问题
* 对数几率回归则适用于分类问题

### 2.4 对数几率回归

* 二分类问题中，$y \in \{0,1\}$，线性回归的预测值是实值，不好用与分类中，而 "单位阶跃函数" unit-step，可以将值转换为0/1.

但是单位阶跃函数不连续，所以不能直接作用在线性回归上，而对数几率函数可以替代单位阶跃函数，且它是连续的。

* 单位阶跃函数与对数几率函数对比：
<!-- ![对数线性回归](/posts/pumpkin-book-notes/logLinearRegression.png) -->
{{< image src="/posts/pumpkin-book-notes/logLinearRegression.png" caption="线性回归" height="346px" width="386px">}}

* 对数几率函数：$y=\frac{1}{1+e^{-(w^Tx+b)}}$
* 它是一种 Sigmoid函数，将 $(w^Tx+b)$，设为 z，该函数将z转化为接近0或1的值
* 其中几率为，得到正例的可能性 和 1 - 得到正例的可能性（即反例）的比值，对这个几率取对数就是叫对数几率（log odds, logit)
* $ln\frac{y}{1-y}=w^Tx+b$

* 对数几率回归优点：
  * 不仅可以预测类别，还可以得到近似的概率预测
  * 对数几率函数是任意阶可导的凸函数（凸函数是可以直接用于求最优解的函数）
  
* 求解对数几率函数中的w和b：极大似然估计

### 2.5 数学基础：极大似然估计 MLE

* 什么时候用极大似然估计：模型已定，参数未知
* 采样要满足的假设：所有采样都要独立同分布
* 正态分布下的极大似然估计的公式：
  * $f(x)=\frac{1}{\sqrt{2\pi}\sigma} exp(-\frac{(x-\mu)^2}{2\sigma^2})$

$P(x|\theta)$ 输入有两个，一个x，一个是模型的参数 $\theta$

* 概率函数：$\theta$ 已知，x是变量；描述对于不同样本点x，其出现概率是多少
* 似然函数：x已知，$\theta$是变量；描述对于不同的模型参数，出现x这个样本点的概率是多少。

[极大似然估计的数学例子](https://zhuanlan.zhihu.com/p/26614750)

* 如何求极大似然估计？
  * 令其导数=0，理解起立就是，函数有切线，函数中不同的位置对应着不同的切线，如何找到极值点？就是当它切线与x轴平行的时候，即切线斜率=0的时候，而这个切线斜率就是函数对应的导数。

### 2.6 数学基础：贝叶斯公式 Bayes

* 区分概率和统计：前者已知模型和参数，推数据；后者已知数据，推模型和参数。

* 贝叶斯公式:
  * $P(A|B)=\frac{P(B|A)P(A)}{P(B)}$，核心就是条件概率和联合概率
  * 把B展开：
    * $P(A|B)=\frac{P(B|A)P(A)}{P(B|A)|(A)+P(B|\sim A)P(\sim A)}$，其中 ~A表示非A
* 贝叶斯公式就是在描述，How much you can trust evidence
  * 理解公式和思想的例子：一辆车的警报响了；
    * 事件A表示车被砸
    * 事件B表示警报响
    * P(A|B)表示警报响了并且车被砸了概率
    * P(B|A)表示车被砸引发了警报的概率
    * P(B|~A)表示警报响了，但是车并没有被砸

### 2.7 线性判别分析 (Linear Discriminant Analysis LDA)

* 线性判别分析主要用于分类问题，也叫 Fisher判别分析，是一种监督降维方法

* LDA思想：设法将样本投影到一条直线上，使样本在这条线上最容易分类；要求，同类近，异类远

* 线性判别模型：采用直线或超平面将样本直接切开，表示为 y = f(w^T x + b)，划分平面表示为 w^T x + b = 0。常见模型，逻辑回归（sigmod函数）、感知机（激活函数）
* 其中 w就是我们要找的投影线的向量，我们只关心向量方向，而不关心模长

* 为了让异类样本相隔远，就需要让异类均值的差大，让同类间离散小，就需要同类的协方差小
* 最大化目标：$J=\frac{||w^T \mu_0 - w^T \mu_1||^2_2}{w^T \Sigma_0 w + w^T \Sigma_1 w}$ 展开得 $\frac{w^T(\mu_0 - \mu_1)(\mu_0 - \mu_1)^Tw}{w^T(\Sigma_0+\Sigma_1)w}$
* 类内方差小 min，类间均值大 max
  * within-class scatter matrix: $S_w = \Sigma_0 + \Sigma_1$
  * between-class scatter matrix: $S_b = (\mu_0-\mu_1)(\mu0-\mu_1)^T$
* 改写后，$J = \frac{w^T S_b w}{w^T S_w w}$，这就是LDA的最大化目标，即 Sb和Sw的广义瑞利商（generalized rayleigh quotient），要求的就是 max J
  * 此时，max J 不可解，因为w会被约掉；但由于w的大小并不会影响最终结果，因为只需要确定w方向。因此，解决方案就是 固定w的大小，固定的方式有很多种，书中是将分母大小固定，$w^T S_w w = 1$：
    * 已知 Sw的大小是固定的，为什么？因为给定样本后，Sw是个固定的矩阵，是个常量；这么做就等价于固定w的模长（不管固定分子还是分母都是可以的，因为样本给定后，均值和方差都是固定的）
  * 所以 max J = $w^T S_b w$，s.t. $w^T S_w w=1$
  * 而通常优化问题都是转化成最小化问题，那么此时 max J -> min J:
    * $min_w J = - w^T S_b w$，s.t. $w^T S_w w=1$
    * 求解带约束的优化问题的常用方法：拉格朗日乘子法

### 2.8 数学基础：拉格朗日乘子法

* 对于仅含约束的优化问题：
  * $min_x f(x)$，s.t. $h_i(x)=0$，i = 1,2,...,n
* 其中自变量x属于实数，f(x)和hi(x)均有连续的一阶偏导数。首先推出其拉格朗日函数：
  * $L(x, \lambda) = f(x) + \sum_{i=1}^n \lambda_i h_i(x)$
* 其中 $\lambda = (\lambda_1, \lambda_2,...,\lambda_n)^T$ 为拉格朗日乘子。然后对拉格朗日函数关于x求偏导。并令导数=0，再搭配约束条件 $h_i(x)=0$解出x，求解出所有x即为上述优化问题的所有可能（极值点）（只能求出1个或者多个局部极值点，不能确定哪个是想要的）

* 求解 w
  * $min_w J = - w^T S_b w$，s.t. $w^T S_w w-1=0$，其中 $w^T S_w w-1=0$ 就是 h(x)
  * 由拉格朗日乘子法可得拉格朗日函数：$L(w, \lambda) = -w^TS_b w + \lambda(w^TS_w w - 1)$，也就是 f(x)+h(x)
  * 对 w 求偏导：
    * $\frac{\partial L(w, \lambda)}{\partial w} = - \frac{\partial (w^T S_b w)}{\partial w} + \lambda \frac{\partial (w^T S_w w - 1)}{\partial w}$
    * $= -(S_b + S_b^T)w + \lambda(S_w + S^T_w)w$
  * 由于 Sb=Sb^T，Sw=Sw^T（因为Sb和Sw都是对称矩阵），所以：
    * $L(w, \lambda) = -2 S_b w + 2 \lambda S_w w$
  * 令上式 = 0：
    * $S_b w = \lambda S_w w$ (广义特征值)
      * 特征值：$Ax = \lambda x$
      * 广义特征值：$Ax = \lambda B x$
  * 将Sb和Sw展开：$(\mu_0-\mu_1)(\mu_0-\mu_1)^T w = \lambda S_w w$
    * 其中，$\mu_0$ 和 $\mu_1$ 是列向量，它们相减还是列向量，$(\mu_0-\mu_1)^T$是行向量，w是列向量；行向量*列向量 = 实数，所以：
    * 令 $(\mu_0 - \mu_1)^T w = \gamma$，则：
      * $\gamma (\mu_1 - \mu_2) = \lambda S_w w$
      * $w = \frac{\gamma}{\lambda} S^{-1}_w (\mu_0 - \mu_1)$
  * 由于最终求解的w不关心其大小，只关心方向，所以令常数项=1，即$\frac{\gamma}{\lambda}=1$，此时有：
    * $w = S^{-1}_w (\mu_0 - \mu_1)$

### 2.9 数学基础：广义特征值

* 定义：设A, B为 n阶方阵，若存在 $\lambda$，使得方程 $Ax=\lambda Bx$ 存在**非零解**，则称 $\lambda$ 为A相对于 B的特征广义指，x为A相对于B的属于广义特征值 $\lambda$ 的特征向量。
  * 特别地，当 B = I（单位矩阵）时，广义特征值问题退化为标准特征值问题。

### 2.10 数学基础：广义瑞利商

* 定义：设A, B为 n阶厄米（Hermitian）矩阵，且B正定，称 $R(x)=\frac{x^H Ax}{x^H Bx}$ (x != 0) 为A相对于B的广义瑞利商。
  * 特别地，当 B = I（单位矩阵）时，广义瑞利商退化为瑞利商。
  * 其中，当矩阵是实数矩阵时，厄米矩阵就等于转置，即 $A^H=A^T$，此时 A和A^H对称；而当元素为复数时，会有不同。
* 性质：假设，$\lambda_i, x_i (i=1,2,...,n)$ 为A相对于B的广义特征值和特征向量，且 $\lambda_1 <= \lambda_2 <= ... <= \lambda_n$，则有：
  * $min_{x != 0} \ \ R(X) = \frac{x^H Ax}{x^H bx} = \lambda_1, \ \ x^* = x_1$
  * $max_{x!=0} \ \ R(x) = \frac{x^H Ax}{x^H Bx} = \lambda_n, \ \ x^* = x_n$

### 2.11 多分类问题

* 学习：一般是利用二分类学习器解决多分类问题，通过拆解法，将多分类任务拆为若干个二分类任务求解。
* 测试：对这些分类器的预测结果集成得到多分类结果。
* 拆分策略：
  * One vs One
    * 将N个类别两两配对，产生N(N-1)/2个二分类任务（也就是训练N(N-1)/2个分类器）
    * 测试阶段，新样本提交给所有的分类器，得到N(N-1)/2个分类结果，把预测最多的类别作为最终结果
    * 存储开销和测试开销会大
  * One vs Rest
    * 将一个类的样例作为正例，其余全部作为反例，来训练N个分类器
    * 测试阶段，仅有一个分类器预测为正类，则对应的类别标记作为最终分类结果；若有多个分类器预测为正类，则根据置信度最大的分类器的类别标记作为分类结果
    * 存储开销和测试时间开销通常小于上一个；如果类别很多的情况下，测试时间开销就大于上一个，因为她需要用到全部样例，而上一个朱需要用到两个类的样例
    * 预测性能，二者差不多
  * Many vs Many
    * 每次将若干个类作为正类，若干个其他类作为反类。正反类构造必须有特殊的设计，不能随意选取，常用技术：纠错输出码（Error Correction Output Codes, ECOC）
      * ECOC是将编码的思想引入类别拆分，尽可能在解码过程中具有容错性
      * 工作过程：
        * 编码：对N个类别做M次划分，每次划分将两部分类别分别划分为正反类，从而形成一个二分类训练集，这样产生M个训练集，可以训练出M个分类器
        * 解码：M个分类器分别对测试样本进行预测，这些预测标记组成一个编码。将编码与每个类别的各自编码进行比较，返回其中距离最小的类别作为最终预测结果
      * 类别划分通过编码矩阵（coding matrix） 指定，常见形式 二元码、三元码

### 2.12 类别不平衡问题 class-imbalance

* 前提：分类任务中，不同类别的训练样例数母差别很大，比如，正类样例少，反类样例特别多
* 类别不平衡处理的基本方法：
  * 基本策略：再缩放（rescaling）
    * 几率y/(1-y)反映了正例可能性和反例可能性之比，若其 > 1，则预测为正例；
      * 然而，训练集中正反例数目不同时，令m^+表示正例数目，m^-表示反例数目，则，目测几率是 m^+/m^-
      * 由于，通常假设训练集是真实样本总体的无偏采样，因此观测几率就代表了真实几率。于是，只要分类器的预测几率高于观测几率就判定为正例：
      * y/(1-y) > m^+/m^-，则 预测为正例
      * 而 分类器基于 y/(1-y)进行决策，因此，需要对预测值进行调整，即再缩放：
      * $\frac{y'}{1-y'} = \frac{y}{1-y} \frac{m^-}{m^+}$
    * 弊端：假设往往不成立，即，训练集是真实样本总体的无偏采样
  * 主流做法1：欠采样（undersampling）
    * 直接对训练集里的反类样例进行欠采样，即去除一些反例，使得正反数目接近
    * 优势：开销小
    * 弊端：不能随意丢弃反例，会丢失重要信息，需要通过特定算法来处理
  * 主流做法2：过采样（oversampling）
    * 对训练集里的正类样例进行过采样，即增加一些正例使得正反数目接近
    * 弊端：不能随便对样例进行重复采样，否则会过拟合
  * 主流做法3：阈值移动（threshold-moving）
    * 直接基于原始训练集进行学习，但是在训练好的分类器进行预测时，将$\frac{y'}{1-y'} = \frac{y}{1-y} \frac{m^-}{m^+}$嵌入到其决策过程中

## 3 决策树 Decision Tree

### 3.1 基本流程

一般的，决策树包含根节点、若干内部节点、若干叶节点

* 叶节点：一个决策结果
* 除叶节点：特征测试（属性测试）

父节点传递给子节点什么？

* 将其包含的样本集合，根据属性测试的结果，划分到子节点中（根节点包含的是样本全集）
* 从 根节点 到 每个叶子节点 的路径，对应了一个判定测试序列

决策树学习的目的：

* 生成一颗泛化能力强的树（其基本流程遵循分而治之策略 divide-and conquer）

决策树的生成：递归过程

* 三种情况会导致递归：
  * 当前节点包含的样本 全属于同一类别，即，无需划分
    * 即，将当前节点标记为某一类别叶节点
  * 当前特征（属性）为null，或，所有样本在 所有属性上 取值相同，即，无法划分
    * 即，将其标记为叶节点，其类别是训练集中样本数量最多的类
  * 当前节点包含的 样本集合为null，即，不能划分
    * 将其父节点标记为叶节点，类别为训练集中最多样本最多的类

### 3.2 划分选择

决策树的流程中最重要的是：如何从属性集A中 选择最优划分属性 a？

* 随着划分的进行，让节点 纯度（**purity**）越来越高，即，分支节点所包含的样本属性尽可能地属于同一类别

### 3.3 信息增益 information entropy

一种度量样本纯度的最长用的指标

规定样本集合D中，第k类样本所占比例为pk (k = 1, 2, ..., |y|),那么**信息熵**为：
$$Ent(D) = - \sum_{k=1}^{|y|} p_k log_{2} p_k$$

Ent(D)越小，样本集合D纯度越高，其中，$0 <= Ent(D) <= log_2 |y|$，|y|表示样本类总数，$0 <= p_k <= 1$，$\sum_{k=1}^n p_k = 1$。

* 若令 |y| = n，即集合D就是样本全集，那么，pk = xk，（x指的是样本，不是特征）

[信息熵公式推导](https://notability.com/n/0f8dPBfjS1mOnVKm8BQu7O)

假定存在一个离散属性a，它有个v个取值，使用a对D互粉，就会产生v个分支节点，每个分支节点包含了对应属性a的样本，记D^v。再求出D^v的信息熵后，考虑不同分支节点包含样本数不同，给分支节点赋予权重 $\frac{|D^v|}{|D|}$，（这个权重就是a1在a中的正例占比，D^v即1-正例占比），样本数越多的分支节点，影响越大。由此计算出用属性a对于D进行划分所获得的信息增益（information gain）
$$Gain(D, a) = Ent(D) - \sum_{v=1}^V \frac{|D^v|}{|D|} Ent(D^v)$$

由属性a划分所获得的纯度提升，和信息增益成正比。

因此，可以在生成分支前，先进行决策树的划分属性选择（max)

### 3.4 增益率 Gain Ratio

解决的问题：信息增益准则由于一些偏好（比如，对取值数目多的属性偏好）对预测带来不利影响

$$Grain_ratio(D, a) = \frac{Gain(D, a)}{IV(a)}$$

其中，属性a是固有值（intrinsic value)，属性a取值数目越多，V越大，IV通常越大。

### 3.5 基尼指数 CART Index (Classification and Regression Tree)

CART决策树使用基尼指数来划分属性，数据集D的纯度通过基尼值来度量：
$$Gini(D)=\sum_{k=1}^{|y|} \sum_{k' !=k} p_k p_{k'}$$
$$= 1- \sum_{k=1}^{|y|} p^2_k$$

基尼值反映了D随机抽取两个样本，其类别标记不一致的概率。

基尼值越小，数据集纯度越高。

基尼指数定义：
$$Gini_index(D, a) = \sum_{v=1}^V \frac{|D^v|}{|D|} Gini(D^v)$$

### 3.6 剪枝处理 pruning

* 用途：对付过拟合（避免分支过多）
* 剪枝策略：
  * 预剪枝（prepruning)
    * 场景：决策树生成中
    * 过程：在节点划分前，进行估计；如果当前节点不能提升泛化性能，则终止划分并将当前节点标为叶节点
  * 后剪枝（post-pruing）
    * 场景：生成完整的决策树后
    * 过程：自底向上地对非叶子节点测试，若该节点的子树替换成叶子节点能够提升泛化型，则将该子替换成叶子节点

### 3.7 连续与缺失值

连续值处理：

由于连续值的数目不是有限的，所以不能按照离散属性生成决策树那样处理连续值

* 通过连续属性离散化来处理
  * 比如最简单的策略：二分法（bi-partition)'

$$T_a = (\frac{a^i+a^{i+1}}{2} | 1<= i <= n-1)$$

## 4 神经网络

神经元模型

### 4.1 激活函数 activation function

把值范围压缩到 (0,1)之间，典型的Sigmoid函数

## 4.2 感知机（Perceptron）与多层网络

M-P神经元：

* 单个M-P神经元：感知机（sgn激活函数），对数几率回归（sigmoid激活函数）
* 多个M-P神经元：神经网络

激活函数：模拟抑制和激活，对值做一个压缩处理

感知机：

* 两层神经元，输入层 + 输出层，其中输出层是M-P神经元，称为threhold logic unit
* 把激活函数替换成阶跃函数（符号）的神经元
* 分类模型

感知机公式：

$$y = f(\sum_{i=1}^n w_i x_i - \theta) = f(w^t x - \theta)$$

其中，theta是阈值，f是符号函数

### 4.3 感知机的学习策略

对于权重w和阈值theta可以通过学习得到，

Processing:

* step 1: 假设，有一个误分类样本集合M，找到所有的误分类样本（x,y）（分错类的），对于误分类样本来说
  * 当$w^Tx- \theta >= 0$时，它的分类结果是 y' = 1，然后真实值 y=0；反之，$w^Tx- \theta < 0$时，y'= 0, y = 1；结合两种情形，可得：
  $$(\hat{y} - y) (w^t x - \theta) >= 0$$
  * 所以，对于给定数据集，其损失函数为：
  $$L(w,\theta) = \sum_{x \in M} (\hat{y} - y) (w^t x - \theta)$$
  * 显然，L始终是非负的，且：
    * 无误分类点，损失函数为0
    * 误分类点越少，L就越小
    * 误分类点离超平面越近，L也越小
  * 因此，L是一个关于w、theta连续可导的函数
* step 2: 将感知机模型的学习问题转化为求解损失函数的最优化问题
  * 求解 w、theta:
  $$min_{w,\theta} L(w,\theta) = min_{w,\theta} \sum_{x_i \in{M}} (\hat{y_i}-{y_i})(w^T x_i - \theta)$$
  * 将阈值 theta看作一个固定输入为-1的"哑节点"，所以有:
  $$-\theta = -1*w_{n+1}=x_{n+1}*w_{n+1}$$
  * 解释，把损失函数中的 -theta整体看作是 -1 * theta，把theta看作 w_n+1，本身w只能取到n，人为的在扩充了一个；n被+1，x也受到n的影响，x也被扩充到n+1，而x_n+1恒等于-1，此时，函数变为:
  $$min_{w,\theta} L(w,\theta) = min_{w,\theta} \sum_{x_i \in{M}} (\hat{y_i}-{y_i})(w^T x_i)$$
  * 注，此式的w和x的维度是n+1维，原式子的维度是n维
  * 求新损失函数L(w)的梯度:
  $$\bigtriangledown_wL(w)=\sum_{x_i \in M} (\hat{y_i} - y_i)x_i$$
  * 感知机使用的是随机梯度下降，普通的梯度下降是一次使M中所有的误分类点梯度下降，而随机梯度是一次取某一个误分类点使其梯度下降，然后更新权重w，而w的更新公式:
  $$w \leftarrow w + \triangle w$$
  $$\triangle w = - \eta(\hat{y_i} - y_i)x_i =  \eta( y_i - \hat{y_i})x_i$$
  * 其中 eta是学习率 learning rate；
  * 迭代n多次后求出w（梯度=0），最后求解出来的w通常不唯一，就是会有1<个梯度为0的点（很多局部最优）

### 4.4 多层网络

* 定义：在输入输出中加入 hidden layer
* 多层前馈神经网络（multi-layer feedforward neural networks)：每层神经元与下一层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接

通用近似定理：只需要一个包含足够多神经元的隐层，多层前馈网络就可以以任意精度逼近任意复杂度的连续函数。因此，神经网络即可以做分类又可以做回归任务。

## 4.5 误差逆传播算法 error BackPropagation BP

该算法用来训练多层神经网络，是一个迭代学习算法，每一轮迭代都采用广义的感知机学习规则对参数估计。

## 5 数据处理

### 5.1 数据预处理-简介

### 5.2 数据无量纲化

* 概念：将不同规格的数据转换成同一个规格，或不同分布的数据转成特定分布。
* 优点：
  * 加快求解速度：在核心为梯度或矩阵的算法中，比如逻辑回归、支持向量机、神经网络
  * 提升模型精度：在距离类模型中，比如K近邻、K-Means聚类中；避免某一取值范围特别大的特征对距离计算造成影响
  * 特例：决策树不需要无量纲化，决策树本身就可以把任意数据处理得很好
* 类型：
  * 线性无量纲化：中心化处理（Zero-centered / Mean-subtraction）和 缩放处理（Scale）
    * 中心化本质：让所有记录减去一个固定值，即让样本数据平移到某个位置
    * 缩放本质：通过除以一个固定值，将数据固定在某个范围内（比如，取对数）
  * 非线性无量纲化
* 数据归一化（Normalization 、 min-max scaling）：数据按照最小值中心化后，再按极差（最大-最小）缩放，数据移动了最小值个单位，并会收敛到 [0,1]之间
  * 归一化后的数据服从正态分布
  * feature_range：MinMaxScaler的重要参数，控制数据压缩到的范围，默认[0,1]
  * 公式：$x^*=\frac{x-min(x)}{max(x)-min(x)}$，就是 中心化 / 极差
  * .fit()本质是生成最大值和最小值
* 数据标准化（Standardization、Z-score normalization）：数据按均值中心化后，再按标准化缩放，数据就会服从期望为0，方差为1的正态分布
  * 公式：$x^*=\frac{x-\mu}{\sigma}$
  * .fit()本质是生成均值和方差

### 5.3 数据预处理 - 处理缺失值

#### 5.3.1 数据清洗

从数据集中纠正或消除不准确、损坏、格式错误、重复或不完整的数据的做法称为数据清理。

#### 5.3.2 填补缺失值的重要性

如果没有正确处理缺失的数值，可能会对数据得出错误的结论，这将对建模阶段产生重大影响，会影响最后的结果。

#### 5.3.3 缺失值导致的问题

1. 在缺乏证据的情况下，统计能力，即检验在零假设错误时拒绝该零假设的几率会降低。
2. 数据的丢失可能导致参数估计出现偏差。
3. 具有降低样本代表性的能力。

#### 5.3.4 缺失数据类型

根据数据集或数据中不存在的模式或数据，可以将其分类。

* **完全随机缺失(MCAR)**：
  * 当丢失数据的概率与要获得的精确值或观察到的答案的集合无关时
  * solution: deleting rows or columns
* **随机缺失(MAR)**：
  * 当丢失响应的概率由观察到的响应的集合而不是预期达到的精确缺失值决定时。
  * solution: imputation of data
* 非随机缺失(MNAR)：
  * MNAR 是缺失数据，这类数据案例很难处理，可以对缺失数据进行建模是获得参数的公平近似值的唯一方法
  * solution improve dataset find data

#### 5.3.5 缺失值的类别

* **连续变量或特征** — — 数值数据集，即数字可以是任何类型
* **分类变量或特征** — — 它可以是数值的或客观的类型

#### 5.3.6 缺失值插补类型

插补有多种大小和形式。这是在为我们的应用程序建模以提高精度之前解决数据集中缺失数据问题的方法之一。

1. **单变量插补**或**均值插补**是指仅使用目标变量对值进行插补。
2. **多元插补**： 根据其他因素插补值，例如使用线性回归根据其他变量估计缺失值。
3. **单一插补**： 要构建单个插补数据集，只需在数据集中插补一次缺失值。
4. **大量插补**： 在数据集中多次插补相同的缺失值。这本质上需要重复单个插补以获得大量插补数据集。

